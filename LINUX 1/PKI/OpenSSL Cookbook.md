---
tags:
  - openssl
  - certificates
  - centos
---
TLS Security Guide: [SSL Labs](https://www.ssllabs.com/)

#### Key and Certificate Management

1. Generate a private key
2. Create a Certificate Signing Request (CSR) and send it to a CA
3. Install the CA-provided certificate

#### Generate a Private Key

**Key algorithm**

- `DSA`: Obsolete
- `EdDSA`: Not yet widely supported
- `RSA`: Good
- `ECDSA`: Even better

**Key size**

- `RSA 2048 bits`: Secure
- `ECDSA 256 bits`: Secure

**Passphrase**

Once activated, private keys are kept unprotected in program memory.
Passphrases should be viewed as a mechanism for protecting private keys that are not installed on production systems. Hardware solution is better for production.

> The `genrsa` command is a legacy command. 

#### Generate a RSA key in `PKCS #8` format

```bash
openssl genpkey -out fd.key \
-algorithm RSA \
-pkeyopt rsa_keygen_bits:2048 \
-aes-128-cbc
```

`short public exponent`: 65,537 good

```
-----BEGIN ENCRYPTED PRIVATE KEY----- ( This is PKCS #8 format, good )
MIIFHzBJBgkqhkiG9w0BBQ0wPDAbBgkqhkiG9w0BBQwwDgQIKhT4ME2Fc24CAggA
MB0GCWCGSAFlAwQBAgQQ+T3seFLSnzhAD567p8X5WwSCBNALibKLwfGkiQNssqFt
Les62UE0Z9GHH2hA57fXzCwr6jktxj1MPpecLOUOXJnBvvI09R3ZBRz8ZyhShUgE
...
dud1fLe9UWLBp6xR5dLfBMW9uCyD+5Im40c2/AqItYr5XcenOHyoTjVIv1SCwegM
RIdZyNz8tCWb45aUN9AQ2EOtdQ==
-----END ENCRYPTED PRIVATE KEY-----
```

`BEGIN RSA PRIVATE KEY`: old, generated by the legacy `genrsa` command

To view a key's structure

```bash
openssl pkey -in fd.key -text --noout
```

```
Private-Key: (2048 bit)
modulus:
    00:dd:dc:2c:57:ce:1c:18:b3:3a:2b:80:d2:10:5b:
...
    85:70:65:1a:1d:e3:50:93:91:5d:31:25:02:0b:ae:
    ad:1f
publicExponent: 65537 (0x10001)
privateExponent:
...
```

To extract the public part of a key

```bash
openssl pkey -in 'fd.key' -pubout -out 'fd-public.key'
```

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3dwsV84cGLM6K4DSEFsl
...
HwIDAQAB
-----END PUBLIC KEY-----
```

#### Generate an ECDSA key

Here, instead of an arbitrary key size, for each key you select a `named curve`, which controls key size and other parameters as well. 

Create a 256-bit ECDSA key using the `P-256` (or `secp256r1`) named curve

```bash
openssl genpkey -out fd-ecdsa.key \
-algorithm EC \
-pkeyopt ec_paramgen_curve:P-256 \
-aes-128-cbc
```

> For web server keys, P-256 (sec256r1 or prime256v1, fast and good enough)  and P-384 named curves are used.

To list OpenSSL supported named curves

```bash
openssl ecparam -list_curves
```

#### Encrypting and Decrypting Files 

Public-key encryption is typically used to encrypt a small piece of data (like a symmetric key) rather than the entire file, due to its performance limitations. This is for testing purposes.

Encrypt a file with the public key

```bash
openssl pkeyutl -encrypt -inkey 'PUBLIC KEY' -pubin -in 'FILE' -out 'ENC_FILE'
```

Decrypt the file with the private key

```bash
openssl pkeyutl -decrypt -inkey 'PRIVATE KEY' -in 'ENC_FILE' -out 'DEC_FILE'
```

Compare the original file to the decrypted file to verify

```bash
diff 'ORIGINAL' 'DECRYPTED FILE'
```

#### Signing Files

Generate a SHA-256 hash of the file

```bash
openssl dgst -sha256 -binary -out 'FILE'.sha256 'hello.txt'
```

Sign the hash with the private key

```bash
openssl pkeyutl -sign -inkey 'PRIVATE KEY' -in 'FILE'.sha256 -out 'hello.sig'
```

Verify the signature with the corresponding public key. 
#### Symmetric Key Encryption

This encrypts a small portion of the file. Puts a password on it.

```bash
openssl enc -aes-256-cbc -pbkdf2 -salt -in 'FILE' -out 'ENC_FILE.bin'
```

Decrypt

```bash
openssl enc -d -aes-256-cbc -pbkdf2 -in 'ENC_FILE' -out 'FILE'
```

#### Creating Certificate Signing Requests (CSR)

Formal request asking a CA to sign a certificate, contains the public key of the entity requesting the certificate and info about the entity. A CSR is always signed with the private key corresponding to the public key it carries.

> If a field needs to be empty, use a `dot` instead of hitting Enter. The latter populates the field with a default value!

Create a CSR

```bash
openssl req -new -key 'PRIVATE_KEY.key' -out 'CSR'.csr
```

Check the CSR information

```bash
openssl req -text -in 'CSR'.csr -noout
```

If the info is correct, the CSR is ready to be signed by a CA (private or public)

#### Creating CSRs from Existing Certificates

If simply renewing a certificate, without changing anything about it and the same **public key is required**, a new CSR can be generated from the existing certificate

```bash
openssl x509 -x509toreq -in 'CERT'.crt -out 'CSR'.csr -signkey 'PRIVATE_KEY'.key
```

> It is a best practice to generate a new key every time you apply for a new certificate

#### Unattended CSR Generation

To automate the CSR generation, a custom OpenSSL configuration file can be used. This allows to configure settings that are not possible interactively (e.g., multiple domain names)

`fd.cnf`
```
[ req ]
prompt = no
distinguished_name = dn
req_extensions = req_ext
input_password = 123123

[ dn ]
C = BG
L = Sofia
O = Aground Ltd
OU = IT Department
CN = www.aground.cc
emailAddress = webmaster@aground.cc

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = www.aground.cc
DNS.2 = aground.cc
```

Generate the CSR

```bash
openssl req -new -config 'fd.cnf' -key 'fd.key' -out 'fd.csr'
```

Inspect the CSR

```bash
openssl req -in 'fd'.csr -noout -text
```

```
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: CN=www.aground.cc/emailAddress=webmaster@aground.cc, O=Aground Ltd, L=Sofia, C=BG
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:dd:dc:2c:57:ce:1c:18:b3:3a:2b:80:d2:10:5b:
                Exponent: 65537 (0x10001)
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name:
                DNS:www.aground.cc, DNS:aground.cc
    Signature Algorithm: sha256WithRSAEncryption
         af:9d:09:a0:f8:03:5d:0a:20:d8:ed:04:e9:ef:a5:9f:18:20:
         77:09:a2:8f
-----BEGIN CERTIFICATE REQUEST-----
MIIC7jCCAdYCAQAwcTEXMBUGA1UEAwwOd3d3LmFncm91bmQuY2MxIzAhBgkqhkiG
...
-----END CERTIFICATE REQUEST-----
```

#### Self-signed Certificates

If a CSR exists 

```bash
openssl x509 -req -days 365 -in 'fd.csr' -signkey 'fd.key' -out 'fd.crt'
```

If CSR does not exist

```bash
openssl req -new -x509 -days 365 -key 'fd.key' -out 'fd-ss.crt'
```

#### Creating Certificates Valid for Multiple Hostnames

By default, OpenSSL generates certificates valid for only one hostname. 

www.website.com and website.com is a common scenario

Two mechanisms to support multiple hostnames in a certificate:
* List all desired hostnames using an X.509 extension called "Subject Alternative Name (SAN)"
* Wildcards
* Or a combination of the two (website.com, \*.website.com)

> When a certificate contains alternative names, all common names are ignored. 

A list of subject alternative names (`subjectAltname`) can be specified in an extension file

`fd.ext`
```
subjectAltName = DNS:*.aground.cc,DNS:aground.cc
```

Issue the certificate

```bash
openssl x509 -req -days 365 -in fd.csr \
-signkey fd.key \
-out fd_ext.crt \
-extfile fd.ext
```

#### Key and Certificate Conversion

Commonly used formats

* **Binary (DER)** certificate: Contains an X.509 certificate in its raw form, using DER ASN.1
* **ASCII (PEM) certificate**: *Privacy Enhanced Mail*. Contains a base64-encoded DER certificate with ---BEGIN CERTIFICATE--- header and ---END CERTIFICATE--- footer. Usually seen with only one certificate per file. Allows multiple certificates in one file
* **Legacy OpenSSL key format**: PKCS#1. Newer versions default to PKCS#8 (`genpkey`)
* **PKCS#7 certificates**: A complex format designed for the transport of signed or encrypted data. usually seen with `.p7b` and `.p7c` extensions. Can include the entire certificate chain. Supported by Java's `keytool` utility
* **PKCS#8** key: The default format for the private key store
* **PKCS#12 (PFX) key and certificates**: A complex format that can store and protect a server key along with an entire certificate chain. Seen as `.p12` and `.pfx` extensions. Commonly used in Microsoft products, but also used for client certificates. PFX is used as a synonym for PKCS#12

##### PEM and DER Conversion

Certificate conversion between PEM and DER formats is performed with the `x509` tool. To convert from PEM to DER:

```bash
openssl x509 -inform PEM -in 'cert.pem' -outform DER -out 'cert.der'
```

Convert from DER to PEM

```bash
openssl x509 -inform DER -in 'cert.der' -outform PEM -out 'cert.pem'
```

##### PKCS #12 (PFX) Conversion

To convert a key (fd.key), certificate (fd.crt) and intermediate (fd-chain.crt) certificates into an equivalent single PKCS #12 file

```bash
openssl pkcs12 -export \
-name "My Certificate" \
-out 'fd.p12' \
-inkey 'fd.key' \
-in 'fd.crt' \
-certfile 'fd-chain.crt'
```

The reverse conversion puts all contents into a single file, that must be split manually

```bash
openssl pkcs12 -in 'fd.p12' -out 'fd.pem' -nodes
```

**The final conversion output shouldn't contain anything apart from the encoded key and certificates**. The intermediate certificates must be provided in the correct order, with the issuing certificate following the signed one. Self-signed root certificates should not go into the chain.

To get OpenSSL to split the components, multiple invocations of the `pkcs12` command are required

```bash
openssl pkcs12 -in 'fd.p12' -nocerts -out 'fd.key' -nodes
openssl pkcs12 -in 'fd.p12' -nokeys -clcerts -out 'fd.crt'
openssl pkcs12 -in 'fd.p12' -nokeys -cacerts -out 'fd-chain.crt'
```

##### PKCS #7 Conversion

To convert from PEM to PKCS #7

```bash
openssl crl2pkcs7 -nocrl -out 'fd.p7b' -certfile 'fd.crt' -certfile 'fd-chain.crt'
```

To convert from PKCS #7 to PEM

```bash
openssl pkcs7 -in 'fd.p7b' -print_certs -out 'fd.pem'
```

The fd.pem file needs to be cleaned up and split into the desired components

#### Cipher Suites

Show the system-wide cryptographic policy defined by the operating system

```bash
update-crypto-policies --show
# DEFAULT
```

See the allowed protocols and cipher suites for OpenSSL

`/etc/crypto-policies/back-ends/`
`/usr/share/crypto-policies/DEFAULT/opensslcnf.txt`
```
CipherString = @SECLEVEL=2:kEECDH:kRSA:kEDH:kPSK:kDHEPSK
Ciphersuites = TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
TLS.MinProtocol = TLSv1.2
TLS.MaxProtocol = TLSv1.3
DTLS.MinProtocol = DTLSv1.2
DTLS.MaxProtocol = DTLSv1.2
SignatureAlgorithms = ECDSA+SHA256:ECDSA+SHA384
Groups = X25519:secp256r1
```

To determine which cipher suites are supported by OpenSSL 

```bash
openssl ciphers -v [-s] 'ALL:COMPLEMENTOFALL'
```

`-s`: Lists only allowed ciphers

```
TLS_AES_256_GCM_SHA384 TLSv1.3 Kx=any Au=any Enc=AESGCM(256) Mac=AEAD
```

Cipher suite breakdown, left to right

1. Suite name
2. Required minimum protocol version
3. Key exchange algorithm
4. Authentication algorithm
5. Encryption algorithm and strength
6. MAC (integrity) algorithm

#### Security Levels

*OpenSSL Security Levels* are designed to guarantee minimum security requirements.

Level 0: No restrictions. Insecure. **Do not use**
Level 1: Minimum of 80 bits. Weak. **Do not use**
Level 2: 112 bits. Should be used as a baseline
Level 3: 128 bits. 
Level 4: 192 bits
Level 5: 256 bits

Display ciphers that meet a specified criteria: 

```bash
openssl ciphers -v -s -tls1_2 'ECDHE+AESGCM @SECLEVEL=3'
```

```
ECDHE-ECDSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESGCM(256)  Mac=AEAD
ECDHE-RSA-AES256-GCM-SHA384   TLSv1.2 Kx=ECDH  Au=RSA   Enc=AESGCM(256)  Mac=AEAD
ECDHE-ECDSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESGCM(128)  Mac=AEAD
ECDHE-RSA-AES128-GCM-SHA256   TLSv1.2 Kx=ECDH  Au=RSA   Enc=AESGCM(128)  Mac=AEAD
```

- **`-tls1_2`**: Filters the output to show only ciphers that are compatible with **TLS 1.2**.
- **`'ECDHE+AESGCM @SECLEVEL=3'`**:
    - **`ECDHE+AESGCM`**: Selects cipher suites that use the ECDHE key exchange and AES-GCM encryption.
    - **`@SECLEVEL=3`**: Specifies that only cipher suites meeting **security level 3** should be shown. This level enforces stricter security requirements, such as minimum key lengths and stronger algorithms.

##### Configuring TLS 1.3

TLS 1.3 requires a colon separated list of the suites

```bash
openssl ciphers -v -s -tls1_3 \
-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384
```

```
TLS_AES_128_GCM_SHA256   TLSv1.3 Kx=any   Au=any   Enc=AESGCM(128)   Mac=AEAD
TLS_AES_256_GCM_SHA384   TLSv1.3 Kx=any   Au=any   Enc=AESGCM(256)   Mac=AEAD
```

Apache cipher suite example config

```
SSLCipherSuite TLSv1.3 TLS_AES_128_GCM_SHA256
SSLCipherSuite EECDH+AES128+AESGCM
```

#### Configure OpenSSL Defaults

Determine the location of the default config file

```bash
openssl version -d
```

```
OPENSSLDIR: "/etc/pki/tls"
```

#### Recommended Cipher Configuration

Forward secrecy + strong encryption

128-bit, 
ECDHE key exchange - faster than DHE
Authenticated encryption

In terms of performance: Tell OpenSSL to use ChaCha20 with clients that prefer this cipher over AES
`PrioritizeChaCHa` option: 

```
TLS_AES_128_GCM_SHA256 
TLS_CHACHA20_POLY1305_SHA256 
TLS_AES_256_GCM_SHA384

ECDHE-ECDSA-AES128-GCM-SHA256 
ECDHE-ECDSA-CHACHA20-POLY1305
ECDHE-RSA-AES128-GCM-SHA256 
ECDHE-RSA-CHACHA20-POLY1305
DHE-RSA-AES128-GCM-SHA256 
DHE-RSA-CHACHA20-POLY1305
```

#### Generating DH Parameters

DH key exchange has fallen out of fashion. Used for philosophical purposes (nginx)

```bash
openssl dhparam -out dh-2048.pem 2048
```

`well-known groups` ?

#### Keywords

Cipher suite *keywords* are the basic building block of cipher suite configuration. 
**RC4-SHA** is a keyword that selects exactly one suite. Case-sensitive.
**HIGH**: This is a group keyword, a shortcut that select frequently used cipher suites.

**Group Keywords**

- **DEFAULT**: The default cipher list. Determined at compile time.
- **COMPLETEMENTOFDEFAULT**: 
- **ALL**: All cipher suites except the eNULL ciphers, which must be explicitly enabled.
- **COMPLEMENTOFALL**: The cipher suites not enabled by ALL, currently eNULL
- **HIGH**: Cipher suites with key lengths equal or larger than 128 bits
- **MEDIUM**: Some of the cipher suites using 128-bit encryption
- **LOW**: 64 or 56-bit encryption. Insecure
- **EXP, EXPORT**: 40 and 56-bit. Insecure
- **EXPORT40, EXPORT56**: Insecure
- **TLSv1.2, TLSv1.0, TLSv1. SSLv3, SSLv2**: These keywords do not affect protocol configuration. just the suites. 

Digest keywords select suites that use a particular digest algorithm. SHA256 selects all suites that rely on SHA256 

**Digest Algorithm Keywords**

- **MD5**: Obsolete and Insecure
- **SHA, SHA1**: Insecure
- **SHA256, 384**: Good enough

**Authentication Keywords**

**RSA** is widely used. **ECDSA** quickly catching up

- **aDH**: CSs using DH authentication. Obsolete
- **aDSS,DSS**: 
- **aECDH**: Removed in 1.1.0
- **aECDSA, ECDSA**
- **aNULL**: Cipher suites offering no authentication. Anonymous DH. Insecure
- **aRSA**: The certificates carry RSA keys
- **aPSK**: (Pre-Shared Key) authentication
- **aSRP**: (Secure Remote Password) authentication

**Key Exchange Keywords**

Key exchange keywords select suites based on the key exchange algorithm. Preferred names today are **DHE** and **ECDHE**. Other keywords are for backward compatibility

- **ADH**: Anonymous DH. Insecure
- **AECDH**: Anonymous ECDH. Insecure
- **DHE, EDH**: Cipher suites using ephemeral DH key agreement only
- **ECDHE, EECDH**: Cipher suites using ephemeral ECDH
- **kDHE, kEDH, DH**: Ephemeral DH key agreement + anonymous DH
- **kECDHE, kEECDH, ECDH**: Ephemeral ECDH key agreement + anonymous ECDH
- **kRSA, RSA**
- **kPSK, kECDHEPSK, kDHEPSK, kRSAPSK**: Suites using PSK key exchange

**Cipher Keywords**

- **AES, AESCCM, AESCCM8, AESGCM**
- **ARIA, ARIA128, ARIA256**
- **CAMELIA CAMELIA128,256**: Obsolete
- **CHACHA20**
- **eNULL, NULL**: Insecure
- **IDEA**: Obsolete
- **SEED**: Obsolete
- **3DES, DES, IDEA, RC2, RC4**: Obsolete and Insecure

GOST standard - relevant to the former Soviet countries

**Miscellaneous Keywords**

- **@SECLEVEL**
- **@STRENGTH**

#### Building Cipher Suite Lists

Keywords can be combined (using the + sign) to select only suites that meet several requirements. By default, new suites are appended to the list. The List starts empty.

```bash
openssl ciphers -v -s -tls1_2 'EECDH+AESGCM'
```

```
ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH    Au=RSA  Enc=AESGCM(256) Mac=AEAD
ECDHE-ECDSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESGCM(256) Mac=AEAD
ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH    Au=RSA  Enc=AESGCM(128) Mac=AEAD
ECDHE-ECDSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH
```

The colon character is commonly used to separate keywords. the configuration starts with all suites that use the ECDHE key exchange, followed by all suites that use the DHE key exchange:

```bash
openssl ciphers -v 'ECDHE:DHE'
```

**Keyword Modifiers**

Placed at the beginning of each keyword in order to change the default action (adding to the list) to something else.

* **Append**: Default action, adds suites to the end of the list. Invoked when no modifier is given
* **Delete** ( - ): Remove all matching suites from the list.
* **Permanently delete** ( ! ):  Remove all matching suites from the list, preventing them to be added later by another keyword.
* **Move to the end ( + )**: Move all matching suites to the end of the list. Useful when you want to keep weaker suites enabled but prefer the stronger ones. AES:+AES256 - enables all AES suites but pushes the 256-bit ones to the end.

**Sorting**

**@STRENGTH**: Does not introduce or remove any suites but sorts them in order of descending cipher strength. 

#### Handling Errors

#### Performance

OpenSSL comes with a benchmark tool

```bash
openssl speed [-evp] [-multi '# of CORES'] [algo] [algo]
```

- `algo` can be more specific:
- `aes-128-cbc`: CBC is obsolete. use GCM
- `-evp`: enable hardware acceleration

```
                  sign    verify    sign/s verify/s
rsa 2048 bits 0.000906s 0.000068s   1103.9  14804.2
                              sign    verify    sign/s verify/s
 256 bit ecdsa (nistp256)   0.0001s   0.0002s   7555.9   4178.7
```

#### Creating a Private Certification Authority

> Root key must be kept offline

The Root CA will be used only for for the issuance of subordinate CAs.

`root-ca.conf`
```
[ default ]
name               = root-ca
domain_suffix      = example.com
aia_url            = http://$name.$domain_suffix/$name.crt
crl_url            = http://$name.$domain_suffix/$name.crl
ocsp_url           = http://ocsp.$name.$domain_suffix:9080
name_opt           = utf8,esc_ctrl,multiline,lname,align

[ ca ]
default_ca         = CA_default            # The default ca section

[ ca_dn ]
countryName        = "BG"
organizationName   = "Example"
commonName         = 'Root CA'

[ CA_default ]
home               = .
database           = $home/db/index
serial             = $home/db/serial
crlnumber          = $home/db/crlnumber
certificate        = $home/$name.crt
private_key        = $home/private/$name.key
RANDFILE           = $home/private/random
new_certs_dir      = $home/certs
unique_objects     = no
copy_extensions    = none
default_days       = 3650
default_crl_days   = 365
default_md         = sha256
policy             = policy_c_o_match

[ policy_c_o_match ]
countryName            = match
stateOrProvinceName    = optional
organizationName       = match
organizationalUnitName = optional
commonName             = supplied
emailAddress           = optional

[ req ]
default_bits       = 4096
encrypt_key        = yes
default_md         = sha256
utf8               = yes
string_mask        = utf8only
prompt             = no
distinguished_name = ca_dn
req_extensions     = ca_ext

[ ca_ext ]
basicConstraints   = critical,CA:true
keyUsage           = critical,keyCertSign,cRLSign
subjectKeyIdentifier = hash

[ sub_ca_ext ]
authorityInfoAccess    = @issuer_info
authorityKeyIdentifier = keyid:always
basicConstraints       = critical,CA:true,pathlen:0
crlDistributionPoints  = @crl_info
extendedKeyUsage       = clientAuth,serverAuth
keyUsage               = critical,keyCertSign,cRLSign
nameConstraints        = @name_constraints
subjectKeyIdentifier   = hash

[ crl_info ]
URI.0                  = $crl_url

[ issuer_info ]
caIssuers;URI.0        = $aia_url
OCSP;URI.0             = $ocsp_url

[ name_constraints ]
permitted;DNS.0=EXAMPLE.COM
permitted;DNS.1=EXAMPLE.ORG
excluded;IP.0=0.0.0.0/0.0.0.0
excluded;IP.1=0:0:0:0:0:0:0:0/0:0:0:0:0:0:0:0

[ ocsp_ext ]
authorityKeyIdentifier = keyid:always
basicConstraints       = critical,CA:false
extendedKeyUsage       = OCSPSigning
keyUsage               = critical,digitalSignature
subjectKeyIdentifier   = hash
```

Subordinate CAs need to be constrained, i.e., issue certificates for a subset of domain names and restricted uses.

- `pathlen`: specifies the maximum number of CAs that can appear below this one in a chain. A `pathlen` of zero means the CA cannot sign any sub-CA's, and can only sign end-entity certificates.
- `critical`: Reject the certificate if usage does not meet expectation.
##### Directory Structure

```
/root-ca
├── certs
├── db
│   ├── crlnumber
│   ├── index
│   └── serial
└── private
```

- `certs`: New certificates will be placed here
- `private`: Stores the private keys, one for the CA and the other for the OCSP responder.
- `db`: Used for certificate database (index) and the files that hold the next certificate and CRL serial numbers

> Initialize the certificate serial numbers with a random number generator. Useful when creating and deploying multiple CA certificates with the same dn

```bash
mkdir -p root-ca/{certs,private,db} && cd root-ca
chmod 0700 private
touch db/index
openssl rand -hex 16 > db/serial
echo 1001 > db/crlnumber
```
##### Root CA Generation

Generate the root certificate request

```bash
openssl req -new \
-config root-ca.conf \
-out root-ca.csr \
-keyout private/root-ca.key
```

Sign the request

```bash
openssl ca -selfsign \
-config root-ca.conf \
-in root-ca.csr \
-out root-ca.crt \
-extensions ca_ext
```

Generate a CRL

```bash
openssl ca -gencrl \
-config root-ca.conf \
-out root-ca.crl
```

#### Creating a Certificate for OCSP Signing

**OCSP** (Online Certificate Status Protocol) root responder is a server that provides real-time status information about the validity of digital certificates. Separate from the root CA.

How it works:
1. **Request**: A client sends an OCSP request to the responder, specifying the certificate's serial number.
2. **Response**: The OCSP responder checks its records and responds with the certificate's status
3. **Trust Establishment**: If response is valid, the client proceeds with the connection.

**OSCP Stapling**: To improve performance and privacy, servers can "staple" the OCSP response to their certificate during the SSL handshake, reducing the need for the client to  contact the server directly.

Create the certificate request and key for the responder

```bash
openssl req -new \
-newkey rsa:2048 \
-subj "/C=BG/O=Ohio/CN=OCSP Root Responder" \
-keyout private/root-ocsp.key \
-out root-ocsp.csr
```

Sign the request with the CA

```bash
openssl ca \
-config root-ca.conf \
-in root-ocsp.csr \
-out root-ocsp.crt \
-extensions ocsp_ext \
-days 30
```

Start the OCSP responder

``` bash
openssl ocsp \
-port 9080 \
-index db/index \
-rsigner root-ocsp.crt \
-rkey private/root-ocsp.key \
-CA root-ca.crt \
-text
```

Test the operation of the OCSP responder ( tested locally )

```bash
openssl ocsp \
-issuer root-ca.crt \
-CAfile root-ca.crt \
-cert root-ocsp.crt \
-url http://127.0.0.1:9080
```

```
Response verify OK
root-ocsp.crt: good
        This Update: Jan 11 21:00:23 2025 GMT
```

#### Subordinate CA

`sub-ca.conf`
```
[ default ]
name                = sub-ca
ocsp_url            = http://ocsp.$name.$domain_suffix:9081

[ ca_dn ]
countryName         = "BG" 
organizationName    = "Example"
commonName          = "Sub CA"

[ ca_default ]
default_days        = 365
default_crl_days    = 30
copy_extensions     = copy

[ server_ext ]
authorityInfoAccess    = @issuer_info
authorityKeyIdentifier = keyid,issuer:always
basicConstraints       = critical,CA:false
crlDistributionPoints  = @crl_info
extendedKeyUsage       = clientAuth,serverAuth
keyUsage               = critical,digitalSignature,keyEncipherment
subjectKeyIdentifier   = hash

[ client_ext ]
authorityInfoAccess    = @issuer_info
authorityKeyIdentifier = keyid,issuer:always
basicConstraints       = critical,CA:false
crlDistributionPoints  = @crl_info
extendedKeyUsage       = clientAuth
keyUsage               = critical,digitalSignature
subjectKeyIdentifier   = hash
```

Create the sub-ca private key

```bash
openssl genpkey -out sub-ca.key \
-algorithm RSA \
-pkeyopt rsa_keygen_bits:2048 \
-aes-128-cbc
```

Create the sub-ca CSR

```bash
openssl req -new \
-config sub-ca.conf \
-out sub-ca.csr -key \
private/sub-ca.key
```

Sign the sub-ca CSR

```bash
openssl ca \
-config root-ca.conf \
-in sub-ca.csr \
-out sub-ca.crt \
-extensions sub_ca_ext
```

Use the new sub-ca to issue a server/client certificate

```bash
openssl ca -config sub-ca.conf -in 'SERVER/CLIENT'.csr -out 'SERVER/CLIENT'.crt -extensions client_ext/server_ext
```

To make a certificate chain

```bash
cat 'SUB-CA.crt' 'ROOT-CA.crt' > full-chain.crt
```

Verify the certs against the CA issuer

```bash
openssl verify -CAfile [-CApath] 'full-chain.crt' 'CLIENT/SERVER'.crt
```

```
kavarna.crt: OK
```
#### Revocation

Check out the certificate serial number in the db/index file

```
V 260113163805Z  ->66E34FA51F8A94E06DF0908E246FE3E2 unknown /C=BG/ST=Sofia/O=Ohio/OU=IT/CN=kavarna.ohio.cc
```

Revoke a cert using its serial number. In the certs directory should be a "SERIAL.pem" file.

```bash
openssl ca -revoke certs/'CERT SERIAL NUMBER'.pem -crl_reason superseded -config 'sub-ca.conf'
```

Update the CRL list

```bash
openssl ca -config 'sub-ca.conf' -gencrl -out 'sub-ca.crl'
```

Inspect the CRL file

```bash
openssl crl -in 'sub-ca.crl' -text -noout
```

```
Certificate Revocation List (CRL):
        Version 2 (0x1)
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = BG, O = Ohio, CN = Sub CA
        Last Update: Jan 13 16:46:07 2025 GMT
        Next Update: Feb 12 16:46:07 2025 GMT
        CRL extensions:
            X509v3 CRL Number:
                4098
Revoked Certificates:
    Serial Number: 66E34FA51F8A94E06DF0908E246FE3E0
        Revocation Date: Jan 13 16:45:26 2025 GMT
        CRL entry extensions:
            X509v3 CRL Reason Code:
                Superseded
    Serial Number: 66E34FA51F8A94E06DF0908E246FE3E1
        Revocation Date: Jan 13 16:34:46 2025 GMT
        CRL entry extensions:
            X509v3 CRL Reason Code:
                Superseded
```

#### Connecting to TLS Services

```bash
openssl s_client -crlf \
-connect www.feistyduck.com:443 \
-servername www.feistyduck.com
```

`-showcerts`: Displays the full chain. Shows only the leaf (top) certificate by default

To nominally test if a chain is correct **issuer** of the current leaf should match the **subject** of the next, going top to bottom. The last **issuer** can point to some root that is not in the chain.

```
---
Certificate chain
 0 s:CN=blog.ivanristic.com
   i:C=US, O=Let's Encrypt, CN=R11
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
   v:NotBefore: Dec 19 00:14:26 2024 GMT; NotAfter: Mar 19 00:14:25 2025 GMT
 1 s:C=US, O=Let's Encrypt, CN=R11
   i:C=US, O=Internet Security Research Group, CN=ISRG Root X1
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
   v:NotBefore: Mar 13 00:00:00 2024 GMT; NotAfter: Mar 12 23:59:59 2027 GMT
---
```

**Negotiation Confirmation**: Confirms what was chosen during the handshake.

```
New, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256
```

**Session Details**: Details the parameters of the active session, providing a full overview of the established secure connection.

```
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
```

#### Certificate Verification

> It is very important that the certificate matches the correct DNS names

```
Verify return code: 20 (unable to get local issuer certificate)
```

This could mean that trusted roots have not been correctly configured

```bash
openssl s_client -connect 'HOST':'PORT' -CApath 'CA DIR'
```

`-CAfile 'CA.csr'`: To point to a single CA file

To check if the certificate is correct for the given hostname

```bash
openssl s_client -connect 'HOSTN':'PORT' -verify_hostname 'HOSTNAME'
```

`-verify_ip 'IP'`: For IP verification

If mismatch

```
Verify return code: 62 (Hostname mismatch)
```

Verify the certificate chain

```bash

```

#### Extracting Remote Certificates

By default, the `s_client` tools waits for input until the server times out. Pipe to `echo` to avoid that. Piping to `x509` will display all cert info.

```bash
echo | openssl s_client -connect www.feistyduck.com:443 -showcerts 2>&1 | openssl x509 -noout -text [-fingerprint] [-sha256] > 'OUTPUT'
```

To extract the certificate section only

```bash
echo | openssl s_client -showcerts -connect www.feistyduck.com:443 2>&1 | sed …
--quiet '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > feistyduck.chain
```

#### Testing Protocol Support

`openssl s_client -help`

```bash
openssl s_client -connect www.feistyduck.com:443 -'PROTOCOL VERSION'
```

Protocol versions:
- `tls1_2`, `tls1_3`, `ssl1...
- `-no_tls1`: To exclude a protocol

#### Testing Cipher Suite Configuration

Testing TLS 1.3. Use `-ciphersuites` 

```bash
openssl s_client -connect 'HOST':'PORT' -tls1_3 -ciphersuites 'SUITE'
```

Testing TLS 1.2. Use `-cipher 'CIPHER'`

```bash
openssl s_client -connect 'HOST':'PORT' -no_tls1_3 -cipher 'AESGCM'
```

```
New, TLSv1.2, Cipher is ECDHE-ECDSA-AES128-GCM-SHA256
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-ECDSA-AES128-GCM-SHA256
```

Get the cipher keyword from `Enc=AESGCM` field of the cipher list

To determine of a server supports bad cryptographic primitives, use an old OpenSSL version

```bash
openssl s_client -connect 'HOST':'PORT' -cipher '3DES DES RC2 RC4 IDEA SEED MD5 CAMELLIA aNULL EXPORT LOW'
```

Negotiated cipher

```
New, TLSv1/SSLv3, Cipher is DHE-RSA-CAMELLIA256-SHA
```

Check for suites as least preferred option

```bash
openssl s_client -connect 'HOST':'PORT' -cipher 'DHE ECDHE kRSA +kECDHE +kDHE'
```

#### Testing Cipher Suite Preference

> TLS 1.2 servers should be configured to enforce their cipher suite preferences, ensuring that they negotiate their preferred cipher suite with every client. All TLS 1.3 suites currently are secure, enforcing doesn't matter much.

```bash
openssl s_client -connect www.hardenize.com:443 -tls1_3 -ciphersuites 'FIRST_CHOICE:SECOND_CHOICE'
```

Change the order of the suites. If the same suite is negotiated on both connections, the server is configured to actively select negotiated suites.

#### Testing Named Groups

**Named groups** are predefined cryptographic parameters that are used for key exchange.

```bash
openssl s_client -connect www.hardenize.com:443 -curves X25519
```

```
Server Temp Key: X25519, 253 bits
```

#### Testing Session Resumption

```bash
openssl s_client -connect www.feistyduck.com:443 -reconnect
```

```
Reused, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256
```

#### Keeping Session States across Connections

Persist a connection to a file

```bash
openssl s_client -connect www.feistyduck.com:443 -sess_out sess.pem
```

View the recorded state

```bash
openssl sess_id -in sess.pem -noout -text
```

Connect again using the same session state

```bash
openssl s_client -connect www.feistyduck.com:443 -sess_in sess.pem
```

#### Checking OCSP Revocation

To check just the OCSP url

```bash
openssl x509 -in kavarna.crt -noout -ocsp_uri
```

```
http://ocsp.sub-ca.ohio.cc:9080
```

Submit an OCSP request

```bash
openssl ocsp -issuer 'issuer.crt' -cert 'subject.crt' -url 'ocsp_uri' -CAfile 'issuer.crt'
```

```
WARNING: no nonce in response
Response verify OK
harden.crt: good
        This Update: Jan 14 12:40:26 2025 GMT
        Next Update: Jan 21 11:40:25 2025 GMT
```

```
Responder Error: unauthorized (6)
```

**Nonce**: OpenSSL requests to use nonce as a protection against replay attacks, but the server did not reply with one. This might be disabled to increase performance of the OCSP responders. OCSP responses in this case can be produced in batch, cached and reused.

Options:
- `-no_nonce`: Do not request a nonce 
- `-header Host 'OCSP.FQDN'`: Specify the hostname of the OCSP responder in the **Host** header if you encounter an error message that includes HTTP error code

Final command

```bash
openssl ocsp -issuer 'issuer.crt' -cert 'subject.crt' -url 'ocsp_uri' -CAfile 'issuer.crt' -no_nonce -header Host 'hostname of the OCSP'
```

#### Testing OCSP Stapling

Stapling is requested with the `-status` switch

```bash
openssl s_client -connect 'HOST':'PORT' -status
```

If a server supports stapling, it will display the entire OCSP response

```
OCSP response:
======================================
OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
    Version: 1 (0x0)
    Responder Id: 9077923567C4FFA8CCA9E67BD980797BCC93F938
    Produced At: Jan 13 12:33:43 2025 GMT
    Responses:
    Certificate ID:
      Hash Algorithm: sha1
      Issuer Name Hash: B9BED5F1A61E40B24196B0C29E7E1A9D8BFCB520
      Issuer Key Hash: 9077923567C4FFA8CCA9E67BD980797BCC93F938
      Serial Number: 909C607903C37B6A13C47011F014EFAA
    Cert Status: good
    This Update: Jan 13 12:33:43 2025 GMT
    Next Update: Jan 20 11:33:42 2025 GMT

    Signature Algorithm: ecdsa-with-SHA256
    Signature Value:
        30:44:02:20:3d:49:d3:fb:64:f4:c6:03:2c:4e:c2:1c:62:94:
```

Else

```
OCSP response: no response sent
```

#### Testing CRL Revocation

1. Obtain the certificate to check
2. Obtain the issuing certificate
3. Download and verify the CRL
4. Look for the certificate SN in the CRL

Verify that the CRL is signed by the issuer certificate

```bash
openssl crl -in 'CRL.crl' -inform DER -CAfile 'issuer.crt' -noout
```

```
verify OK
```

```bash
openssl x509 -in 'server cert'.crt -noout -serial
```

Inspect the CRL manually

```bash
openssl crl -in 'CRL.crl' -inform DER -noout -text
```

```
Revoked Certificates:
    Serial Number: CDECA6732A261B8C0D0030827CBD33F3
        Revocation Date: Jan 15 06:57:19 2025 GMT
    Serial Number: CE52C12017E9A67F0D46CE1F0D9511E9
        Revocation Date: Nov  2 08:16:20 2024 GMT
```

#### Testing Renegotiation

> TLS 1.3 no longer supports renegotiation, as it was a protocol weakness

```
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
This TLS version forbids renegotiation.
```

```bash
openssl s_client -connect 'SERVER' -no_tls1_3
```

Here, the server supports secure negotiation via a special TLS extension

```
New, TLSv1.2, Cipher is ECDHE-ECDSA-CHACHA20-POLY1305
Secure Renegotiation IS supported
```

Client-initiated renegotiation makes the server more susceptible to dos attacks. To initiate a renegotiation, type R

```
    Extended master secret: yes
---
R <- type 
RENEGOTIATING
006E5F4DD07F0000:error:0A000153:SSL routines:ssl3_read_bytes:no renegotiation:ssl/record/rec_layer_s3.c:926:
```

#### Test Session Resumptions

```bash
openssl s_client -connect example.com:443 -tls1_2 -reconnect
```
#### Testing for Heartbleed

Requires a modified version of OpenSSL for invasive testing

#### Determining the Strength of Diffie-Hellman Parameters

To do that, connect to the server while offering only suites that use the DH key exchange

```bash
openssl s_client -connect 'HOST:443' -cipher kEDH
```

```
Peer signing digest: SHA512
Peer signature type: RSA
Server Temp Key: DH, 2048 bits
```

```
Peer signing digest: SHA256
Peer signature type: ECDSA
Server Temp Key: X25519, 253 bits
```

Servers that support the *export* suites might offer even weaker DH parameters. To check for that, connect  using old openSSL offering only export DHE suites

```bash
openssl s_client -connect gitlab.ohio.cc:443 -cipher kEDH+EXPORT
```

The command should fail if the server is configured correctly

```
Call to SSL_CONF_cmd(-cipher, kEDH+EXPORT) failed
00AE9300937F0000:error:0A0000B9:SSL routines:SSL_CTX_set_cipher_list:no cipher match:ssl/ssl_lib.c:3329:
```
